{"version":3,"file":"viselect.esm.js","sources":["../src/utils/css.ts","../src/utils/events.ts","../src/utils/intersects.ts","../src/utils/selectAll.ts","../src/utils/constants.ts","../src/utils/deepAssign.ts","../src/index.ts","../src/EventEmitter.ts","../src/utils/frames.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {Properties} from 'csstype';\n\nconst unitify = (val: string | number, unit = 'px'): string => {\n    return typeof val === 'number' ? val + unit : val;\n};\n\n/**\n * Add css to a DOM-Element or returns the current\n * value of a property.\n *\n * @param el The Element.\n * @param attr The attribute or a object which holds css key-properties.\n * @param val The value for a single attribute.\n * @returns {*}\n */\nexport function css(\n    {style}: HTMLElement,\n    attr: Partial<Record<keyof Properties, string | number>> | keyof Properties,\n    val?: string | number\n): void {\n    if (typeof attr === 'object') {\n\n        for (const [key, value] of Object.entries(attr)) {\n            style[key as any] = unitify(value as string | number);\n        }\n\n    } else if (val !== undefined) {\n        style[attr as any] = unitify(val);\n    }\n}\n\n\n","/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype Method = 'addEventListener' | 'removeEventListener';\ntype AnyFunction = (...arg: any) => any;\n\nexport type EventBindingArgs = [\n        EventTarget | EventTarget[],\n        string | string[],\n    AnyFunction,\n    Record<string, unknown>?\n];\n\ninterface EventBinding {\n    (\n        elements: EventTarget | EventTarget[],\n        events: string | string[],\n        fn: AnyFunction,\n        options?: Record<string, unknown>\n    ): EventBindingArgs;\n}\n\n/* eslint-disable prefer-rest-params */\nfunction eventListener(method: Method): EventBinding {\n    return (\n        items: EventTarget | EventTarget[],\n        events: string | string[],\n        fn: AnyFunction, options = {}\n    ): EventBindingArgs => {\n\n        // Normalize array\n        if (items instanceof HTMLCollection || items instanceof NodeList) {\n            items = Array.from(items);\n        } else if (!Array.isArray(items)) {\n            items = [items];\n        }\n\n        if (!Array.isArray(events)) {\n            events = [events];\n        }\n\n        for (const el of items) {\n            for (const ev of events) {\n                el[method](ev, fn as EventListener, {capture: false, ...options});\n            }\n        }\n\n        return [items, events, fn, options];\n    };\n}\n\n/**\n * Add event(s) to element(s).\n * @param elements DOM-Elements\n * @param events Event names\n * @param fn Callback\n * @param options Optional options\n * @return Array passed arguments\n */\nexport const on = eventListener('addEventListener');\n\n/**\n * Remove event(s) from element(s).\n * @param elements DOM-Elements\n * @param events Event names\n * @param fn Callback\n * @param options Optional options\n * @return Array passed arguments\n */\nexport const off = eventListener('removeEventListener');\n\n/**\n * Simplifies a touch / mouse-event\n * @param evt\n */\nexport const simplifyEvent = (evt: any): {\n    tap: MouseEvent | Touch;\n    x: number;\n    y: number;\n    target: HTMLElement;\n} => {\n    const tap = (evt.touches && evt.touches[0] || evt);\n    return {\n        tap,\n        x: tap.clientX,\n        y: tap.clientY,\n        target: tap.target\n    };\n};\n\n/**\n * Polyfill for safari & firefox for the eventPath event property.\n * @param evt The event object.\n * @return [String] event path.\n */\nexport function eventPath(evt: any): EventTarget[] {\n    let path: EventTarget[] = evt.path || (evt.composedPath && evt.composedPath());\n    if (path) {\n        return path;\n    }\n\n    let el = evt.target.parentElement;\n    path = [evt.target, el];\n\n    /* eslint-disable no-cond-assign */\n    while (el = el.parentElement) {\n        path.push(el);\n    }\n\n    path.push(document, window);\n    return path;\n}\n\n","export type Intersection = 'center' | 'cover' | 'touch'\n\n/**\n * Check if two DOM-Elements intersects each other.\n * @param a BoundingClientRect of the first element.\n * @param b BoundingClientRect of the second element.\n * @param mode Options are center, cover or touch.\n * @returns {boolean} If both elements intersects each other.\n */\nexport function intersects(a: DOMRect, b: DOMRect, mode: Intersection = 'touch'): boolean {\n    switch (mode) {\n        case 'center': {\n            const bxc = b.left + b.width / 2;\n            const byc = b.top + b.height / 2;\n\n            return bxc >= a.left &&\n                bxc <= a.right &&\n                byc >= a.top &&\n                byc <= a.bottom;\n        }\n        case 'cover': {\n            return b.left >= a.left &&\n                b.top >= a.top &&\n                b.right <= a.right &&\n                b.bottom <= a.bottom;\n        }\n        case 'touch': {\n            return a.right >= b.left &&\n                a.left <= b.right &&\n                a.bottom >= b.top &&\n                a.top <= b.bottom;\n        }\n        default: {\n            throw new Error(`Unkown intersection mode: ${mode}`);\n        }\n    }\n}\n","export type SelectAllSelectors = readonly (string | Element)[] | string | Element;\n\n/**\n * Takes a selector (or array of selectors) and returns the matched nodes.\n * @param selector The selector or an Array of selectors.\n * @param doc\n * @returns {Array} Array of DOM-Nodes.\n */\nexport function selectAll(selector: SelectAllSelectors, doc: Document = document): Element[] {\n    const list = !Array.isArray(selector) ? [selector] : selector;\n    let nodes: Element[] = [];\n\n    for (let i = 0, l = list.length; i < l; i++) {\n        const item = list[i];\n\n        if (typeof item === 'string') {\n            /**\n             * We can't use the spread operator here as with large amounts of elements\n             * we'll get a \"Maximum call stack size exceeded\"-error.\n             */\n            nodes = nodes.concat(Array.from(doc.querySelectorAll(item)));\n        } else if (item instanceof Element) {\n            nodes.push(item);\n        }\n    }\n\n    return nodes;\n}\n","// Determines if the device's primary input supports touch\n// See this article: https://css-tricks.com/touch-devices-not-judged-size/\nexport const isTouchDevice = (): boolean => matchMedia('(hover: none), (pointer: coarse)').matches;\n\n// Determines if the browser is safari\nexport const isSafariBrowser = (): boolean => 'safari' in window;\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\nexport const deepAssign = <O extends Record<any, any>>(target: O, source: any): O => {\n    for (const [key, value] of Object.entries(target)) {\n        const sourceValue = source[key];\n\n        // Use the default value if there's no value specified\n        target[key as keyof O] = sourceValue === undefined ? target[key as keyof O] :\n\n            // Check if it's a nested object and merge if required\n            (typeof sourceValue === 'object' && typeof value === 'object' && value !== null && !Array.isArray(value)) ?\n                deepAssign(value as O, sourceValue as Partial<O>) : sourceValue;\n    }\n\n    return target;\n};\n","import {EventTarget} from './EventEmitter';\nimport type {AreaLocation, Coordinates, ScrollEvent, SelectionEvents, SelectionOptions, SelectionStore} from './types';\nimport {PartialSelectionOptions} from './types';\nimport {css, deepAssign, eventPath, frames, Frames, intersects, isSafariBrowser, isTouchDevice, off, on, selectAll, SelectAllSelectors, simplifyEvent} from './utils';\n\n// Re-export types\nexport * from './types';\n\n// Some var shorting for better compression and readability\nconst {abs, max, min, ceil} = Math;\n\nexport default class SelectionArea extends EventTarget<SelectionEvents> {\n    public static version = VERSION;\n\n    // Options\n    private readonly _options: SelectionOptions;\n\n    // Selection store\n    private _selection: SelectionStore = {\n        stored: [],\n        selected: [],\n        touched: [],\n        changed: {\n            added: [], // Added elements since last selection\n            removed: [] // Removed elements since last selection\n        }\n    };\n\n    // Area element and clipping element\n    private readonly _area: HTMLElement;\n    private readonly _clippingElement: HTMLElement;\n\n    // Target container (element) and boundary (cached)\n    private _targetElement?: Element;\n    private _targetRect?: DOMRect;\n    private _selectables: Element[] = [];\n    private _latestElement?: Element;\n\n    // Caches the position of the selection-area\n    private readonly _areaRect = new DOMRect();\n\n    // Dynamically constructed area rect\n    private _areaLocation: AreaLocation = {y1: 0, x2: 0, y2: 0, x1: 0};\n\n    // If a single click is being performed.\n    // It's a single-click until the user dragged the mouse.\n    private _singleClick = true;\n    private _frame: Frames;\n\n    // Is getting set on movement.\n    private _scrollAvailable = true;\n    private _scrollingActive = false;\n    private _scrollSpeed: Coordinates = {x: 0, y: 0};\n    private _scrollDelta: Coordinates = {x: 0, y: 0};\n\n    constructor(opt: PartialSelectionOptions) {\n        super();\n\n        this._options = deepAssign<SelectionOptions>({\n            selectionAreaClass: 'selection-area',\n            selectionContainerClass: undefined,\n            selectables: [],\n            document: window.document,\n\n            behaviour: {\n                overlap: 'invert',\n                intersect: 'touch',\n                startThreshold: {x: 10, y: 10},\n                scrolling: {\n                    speedDivider: 10,\n                    manualSpeed: 750,\n                    startScrollMargins: {x: 0, y: 0}\n                }\n            },\n\n            features: {\n                range: true,\n                touch: true,\n                singleTap: {\n                    allow: true,\n                    intersect: 'native'\n                }\n            },\n\n            startAreas: ['html'],\n            boundaries: ['html'],\n            container: 'body'\n        }, opt);\n\n        // Bind locale functions to instance\n        /* eslint-disable @typescript-eslint/no-explicit-any */\n        for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {\n            if (typeof (this as any)[key] === 'function') {\n                (this as any)[key] = (this as any)[key].bind(this);\n            }\n        }\n\n        const {document, selectionAreaClass, selectionContainerClass} = this._options;\n        this._area = document.createElement('div');\n        this._clippingElement = document.createElement('div');\n        this._clippingElement.appendChild(this._area);\n\n        this._area.classList.add(selectionAreaClass);\n        selectionContainerClass && this._clippingElement.classList.add(selectionContainerClass);\n\n        css(this._area, {\n            willChange: 'top, left, bottom, right, width, height',\n            top: 0,\n            left: 0,\n            position: 'fixed'\n        });\n\n        css(this._clippingElement, {\n            overflow: 'hidden',\n            position: 'fixed',\n            transform: 'translate3d(0, 0, 0)', // https://stackoverflow.com/a/38268846\n            pointerEvents: 'none',\n            zIndex: '1'\n        });\n\n        this._frame = frames((evt: MouseEvent | TouchEvent) => {\n            this._recalculateSelectionAreaRect();\n            this._updateElementSelection();\n            this._emitEvent('move', evt);\n            this._redrawSelectionArea();\n        });\n\n        this.enable();\n    }\n\n    _bindStartEvents(activate = true): void {\n        const {document, features} = this._options;\n        const fn = activate ? on : off;\n\n        fn(document, 'mousedown', this._onTapStart);\n        features.touch && fn(document, 'touchstart', this._onTapStart, {\n            passive: false\n        });\n    }\n\n    _onTapStart(evt: MouseEvent | TouchEvent, silent = false): void {\n        const {x, y, target} = simplifyEvent(evt);\n        const {_options} = this;\n        const {document} = this._options;\n        const targetBoundingClientRect = target.getBoundingClientRect();\n\n        // Find start-areas and boundaries\n        const startAreas = selectAll(_options.startAreas, _options.document);\n        const resolvedBoundaries = selectAll(_options.boundaries, _options.document);\n\n        // Check in which container the user currently acts\n        this._targetElement = resolvedBoundaries.find(el =>\n            intersects(el.getBoundingClientRect(), targetBoundingClientRect)\n        );\n\n        // Check if area starts in one of the start areas / boundaries\n        const evtPath = eventPath(evt);\n        if (!this._targetElement ||\n            !startAreas.find(el => evtPath.includes(el)) ||\n            !resolvedBoundaries.find(el => evtPath.includes(el))) {\n            return;\n        }\n\n        if (!silent && this._emitEvent('beforestart', evt) === false) {\n            return;\n        }\n\n        this._areaLocation = {x1: x, y1: y, x2: 0, y2: 0};\n\n        // Lock scrolling in target container\n        const scrollElement = document.scrollingElement || document.body;\n        this._scrollDelta = {x: scrollElement.scrollLeft, y: scrollElement.scrollTop};\n\n        // To detect single-click\n        this._singleClick = true;\n        this.clearSelection(false);\n\n        on(document, ['touchmove', 'mousemove'], this._delayedTapMove, {passive: false});\n        on(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n        on(document, 'scroll', this._onScroll);\n    }\n\n    _onSingleTap(evt: MouseEvent | TouchEvent): void {\n        const {singleTap: {intersect}, range} = this._options.features;\n        const e = simplifyEvent(evt);\n        let target = null;\n\n        if (intersect === 'native') {\n            target = e.target;\n        } else if (intersect === 'touch') {\n            this.resolveSelectables();\n\n            const {x, y} = e;\n            target = this._selectables.find(v => {\n                const {right, left, top, bottom} = v.getBoundingClientRect();\n                return x < right && x > left && y < bottom && y > top;\n            });\n        }\n\n        if (!target) {\n            return;\n        }\n\n        /**\n         * Resolve selectables again.\n         * If the user started in a scrollable area they will be reduced\n         * to the current area. Prevent the exclusion of these if a range-selection\n         * gets performed.\n         */\n        this.resolveSelectables();\n\n        // Traverse dom upwards to check if target is selectable\n        while (!this._selectables.includes(target)) {\n            if (!target.parentElement) {\n                return;\n            }\n\n            target = target.parentElement;\n        }\n\n        // Grab current store first in case it gets set back\n        const {stored} = this._selection;\n        this._emitEvent('start', evt);\n\n        if (evt.shiftKey && stored.length && range) {\n            const reference = this._latestElement ?? stored[0];\n\n            // Resolve correct range\n            const [preceding, following] = reference.compareDocumentPosition(target) & 4 ?\n                [target, reference] : [reference, target];\n\n            const rangeItems = [...this._selectables.filter(el =>\n                (el.compareDocumentPosition(preceding) & 4) &&\n                (el.compareDocumentPosition(following) & 2)\n            ), preceding, following];\n\n            this.select(rangeItems);\n        } else if (\n            stored.includes(target) && (\n                stored.length === 1 || evt.ctrlKey ||\n                stored.every(v => this._selection.stored.includes(v))\n            )\n        ) {\n            this.deselect(target);\n        } else {\n            this._latestElement = target;\n            this.select(target);\n        }\n\n        this._emitEvent('stop', evt);\n    }\n\n    _delayedTapMove(evt: MouseEvent | TouchEvent): void {\n        const {container, document, behaviour: {startThreshold}} = this._options;\n        const {x1, y1} = this._areaLocation; // Coordinates of first \"tap\"\n        const {x, y} = simplifyEvent(evt);\n\n        // Check pixel threshold\n        const thresholdType = typeof startThreshold;\n        if (\n\n            // Single number for both coordinates\n            (thresholdType === 'number' && abs((x + y) - (x1 + y1)) >= startThreshold) ||\n\n            // Different x and y threshold\n            (thresholdType === 'object' && abs(x - x1) >= (startThreshold as Coordinates).x || abs(y - y1) >= (startThreshold as Coordinates).y)\n        ) {\n            off(document, ['mousemove', 'touchmove'], this._delayedTapMove, {passive: false});\n\n            if (this._emitEvent('beforedrag', evt) === false) {\n                off(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n                return;\n            }\n\n            on(document, ['mousemove', 'touchmove'], this._onTapMove, {passive: false});\n\n            // Make area element visible\n            css(this._area, 'display', 'block');\n\n            // Append selection-area to the dom\n            selectAll(container, document)[0].appendChild(this._clippingElement);\n\n            this.resolveSelectables();\n\n            // An action is recognized as single-select until the user performed a multi-selection\n            this._singleClick = false;\n\n            // Just saving the boundaries of this container for later\n            this._targetRect = this._targetElement!.getBoundingClientRect();\n\n            // Find container and check if it's scrollable\n            this._scrollAvailable =\n                this._targetElement!.scrollHeight !== this._targetElement!.clientHeight ||\n                this._targetElement!.scrollWidth !== this._targetElement!.clientWidth;\n\n            if (this._scrollAvailable) {\n\n                // Detect mouse scrolling\n                on(document, 'wheel', this._manualScroll, {passive: false});\n\n                /**\n                 * The selection-area will also cover other element which are\n                 * out of the current scrollable parent. So find all elements\n                 * which are in the current scrollable element. Later these are\n                 * the only selectables instead of all.\n                 */\n                this._selectables = this._selectables.filter(s => this._targetElement!.contains(s));\n            }\n\n            // Re-setup selection area and fire event\n            this._setupSelectionArea();\n            this._emitEvent('start', evt);\n            this._onTapMove(evt);\n        }\n\n        this._handleMoveEvent(evt);\n    }\n\n    _setupSelectionArea(): void {\n        const {_clippingElement, _targetElement, _area} = this;\n        const tr = this._targetRect = _targetElement!.getBoundingClientRect();\n\n        if (this._scrollAvailable) {\n\n            /**\n             * To clip the area, the selection area has a parent\n             * which has exact the same dimensions as the scrollable element.\n             * Now if the area exceeds these boundaries it will be cropped.\n             */\n            css(_clippingElement, {\n                top: tr.top,\n                left: tr.left,\n                width: tr.width,\n                height: tr.height\n            });\n\n            /**\n             * The area element is relative to the clipping element,\n             * but when this is moved or transformed we need to correct\n             * the positions via a negative margin.\n             */\n            css(_area, {\n                marginTop: -tr.top,\n                marginLeft: -tr.left\n            });\n        } else {\n\n            // \"Reset\" styles\n            css(_clippingElement, {\n                top: 0,\n                left: 0,\n                width: '100%',\n                height: '100%'\n            });\n\n            css(_area, {\n                marginTop: 0,\n                marginLeft: 0\n            });\n        }\n    }\n\n    _onTapMove(evt: MouseEvent | TouchEvent): void {\n        const {x, y} = simplifyEvent(evt);\n        const {_scrollSpeed, _areaLocation, _options, _frame} = this;\n        const {speedDivider} = _options.behaviour.scrolling;\n        const _targetElement = this._targetElement as Element;\n\n        _areaLocation.x2 = x;\n        _areaLocation.y2 = y;\n\n        if (this._scrollAvailable && !this._scrollingActive && (_scrollSpeed.y || _scrollSpeed.x)) {\n\n            // Continuous scrolling\n            this._scrollingActive = true;\n\n            const scroll = () => {\n                if (!_scrollSpeed.x && !_scrollSpeed.y) {\n                    this._scrollingActive = false;\n                    return;\n                }\n\n                // Reduce velocity, use ceil in both directions to scroll at least 1px per frame\n                if (_scrollSpeed.y) {\n                    const distance = ceil(_scrollSpeed.y / speedDivider);\n                    _targetElement.scrollTop += distance;\n                    _areaLocation.y1 -= distance;\n                }\n\n                if (_scrollSpeed.x) {\n                    const distance = ceil(_scrollSpeed.x / speedDivider);\n                    _targetElement.scrollLeft += distance;\n                    _areaLocation.x1 -= distance;\n                }\n\n                /**\n                 * We changed the start coordinates -> redraw the selection-area\n                 * We changed the dimensions of the area element -> re-calc selected elements\n                 * The selected elements array has been changed -> fire event\n                 */\n                _frame.next(evt);\n\n                // Keep scrolling even if the user stops to move his pointer\n                requestAnimationFrame(scroll);\n            };\n\n            requestAnimationFrame(scroll);\n        } else {\n\n            /**\n             * Perform redraw only if scrolling is not active.\n             * If scrolling is active this area is getting re-dragged by the\n             * anonymize scroll function.\n             */\n            _frame.next(evt);\n        }\n\n        this._handleMoveEvent(evt);\n    }\n\n    _handleMoveEvent(evt: MouseEvent | TouchEvent) {\n        const {features} = this._options;\n\n        /**\n         * - Prevent auto-refresh for when pulling down on touch devices.\n         * - Prevent auto-scroll by the browser when on safari and scrolling is handled by viselect.\n         */\n        if ((features.touch && isTouchDevice()) || (this._scrollAvailable && isSafariBrowser())) {\n            evt.preventDefault(); // Prevent swipe-down refresh\n        }\n    }\n\n    _onScroll(): void {\n        const {_scrollDelta, _options: {document}} = this;\n        const {scrollTop, scrollLeft} = document.scrollingElement || document.body;\n\n        // Adjust area start location\n        this._areaLocation.x1 += _scrollDelta.x - scrollLeft;\n        this._areaLocation.y1 += _scrollDelta.y - scrollTop;\n        _scrollDelta.x = scrollLeft;\n        _scrollDelta.y = scrollTop;\n\n        // The area needs to be set back as the target-container has changed in its position\n        this._setupSelectionArea();\n        this._frame.next(null);\n    }\n\n    _manualScroll(evt: ScrollEvent): void {\n        const {manualSpeed} = this._options.behaviour.scrolling;\n\n        // Consistent scrolling speed on all browsers\n        const deltaY = evt.deltaY ? (evt.deltaY > 0 ? 1 : -1) : 0;\n        const deltaX = evt.deltaX ? (evt.deltaX > 0 ? 1 : -1) : 0;\n        this._scrollSpeed.y += deltaY * manualSpeed;\n        this._scrollSpeed.x += deltaX * manualSpeed;\n        this._onTapMove(evt);\n\n        // Prevent default scrolling behaviour, e.g. page scrolling\n        evt.preventDefault();\n    }\n\n    _recalculateSelectionAreaRect(): void {\n        const {_scrollSpeed, _areaLocation, _areaRect, _targetElement, _options} = this;\n        const {scrollTop, scrollHeight, clientHeight, scrollLeft, scrollWidth, clientWidth} = _targetElement as Element;\n        const _targetRect = this._targetRect as DOMRect;\n\n        const {x1, y1} = _areaLocation;\n        let {x2, y2} = _areaLocation;\n\n        const {behaviour: {scrolling: {startScrollMargins}}} = _options;\n\n        if (x2 < _targetRect.left + startScrollMargins.x) {\n            _scrollSpeed.x = scrollLeft ? -abs(_targetRect.left - x2 + startScrollMargins.x) : 0;\n            x2 = x2 < _targetRect.left ? _targetRect.left : x2;\n        } else if (x2 > _targetRect.right - startScrollMargins.x) {\n            _scrollSpeed.x = scrollWidth - scrollLeft - clientWidth ? abs(_targetRect.left + _targetRect.width - x2 - startScrollMargins.x) : 0;\n            x2 = x2 > _targetRect.right ? _targetRect.right : x2;\n        } else {\n            _scrollSpeed.x = 0;\n        }\n\n        if (y2 < _targetRect.top + startScrollMargins.y) {\n            _scrollSpeed.y = scrollTop ? -abs(_targetRect.top - y2 + startScrollMargins.y) : 0;\n            y2 = y2 < _targetRect.top ? _targetRect.top : y2;\n        } else if (y2 > _targetRect.bottom - startScrollMargins.y) {\n            _scrollSpeed.y = scrollHeight - scrollTop - clientHeight ? abs(_targetRect.top + _targetRect.height - y2 - startScrollMargins.y) : 0;\n            y2 = y2 > _targetRect.bottom ? _targetRect.bottom : y2;\n        } else {\n            _scrollSpeed.y = 0;\n        }\n\n        const x3 = min(x1, x2);\n        const y3 = min(y1, y2);\n        const x4 = max(x1, x2);\n        const y4 = max(y1, y2);\n\n        _areaRect.x = x3;\n        _areaRect.y = y3;\n        _areaRect.width = x4 - x3;\n        _areaRect.height = y4 - y3;\n    }\n\n    _redrawSelectionArea(): void {\n        const {x, y, width, height} = this._areaRect;\n        const {style} = this._area;\n\n        // Using transform will make the area's borders look blurry\n        style.left = `${x}px`;\n        style.top = `${y}px`;\n        style.width = `${width}px`;\n        style.height = `${height}px`;\n    }\n\n    _onTapStop(evt: MouseEvent | TouchEvent | null, silent: boolean): void {\n        const {document, features} = this._options;\n        const {_singleClick} = this;\n\n        // Remove event handlers\n        off(document, ['mousemove', 'touchmove'], this._delayedTapMove);\n        off(document, ['touchmove', 'mousemove'], this._onTapMove);\n        off(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n        off(document, 'scroll', this._onScroll);\n\n        // Keep selection until the next time\n        this._keepSelection();\n\n        if (evt && _singleClick && features.singleTap.allow) {\n            this._onSingleTap(evt);\n        } else if (!_singleClick && !silent) {\n            this._updateElementSelection();\n            this._emitEvent('stop', evt);\n        }\n\n        this._scrollSpeed.x = 0;\n        this._scrollSpeed.y = 0;\n\n        // Unbind mouse scrolling listener\n        this._scrollAvailable && off(document, 'wheel', this._manualScroll, {passive: true});\n\n        // Remove selection-area from dom\n        this._clippingElement.remove();\n\n        // Cancel current frame\n        this._frame?.cancel();\n\n        // Hide selection area\n        css(this._area, 'display', 'none');\n    }\n\n    _updateElementSelection(): void {\n        const {_selectables, _options, _selection, _areaRect} = this;\n        const {stored, selected, touched} = _selection;\n        const {intersect, overlap} = _options.behaviour;\n\n        const invert = overlap === 'invert';\n        const newlyTouched: Element[] = [];\n        const added: Element[] = [];\n        const removed: Element[] = [];\n\n        // Find newly selected elements\n        for (let i = 0; i < _selectables.length; i++) {\n            const node = _selectables[i];\n\n            // Check if area intersects element\n            if (intersects(_areaRect, node.getBoundingClientRect(), intersect)) {\n\n                // Check if the element wasn't present in the last selection.\n                if (!selected.includes(node)) {\n\n                    // Check if user wants to invert the selection for already selected elements\n                    if (invert && stored.includes(node)) {\n                        removed.push(node);\n                        continue;\n                    } else {\n                        added.push(node);\n                    }\n                } else if (stored.includes(node) && !touched.includes(node)) {\n                    touched.push(node);\n                }\n\n                newlyTouched.push(node);\n            }\n        }\n\n        // Re-select elements which were previously stored\n        if (invert) {\n            added.push(...stored.filter(v => !selected.includes(v)));\n        }\n\n        // Check which elements where removed since last selection\n        const keep = overlap === 'keep';\n        for (let i = 0; i < selected.length; i++) {\n            const node = selected[i];\n\n            if (!newlyTouched.includes(node) && !(\n\n                // Check if user wants to keep previously selected elements, e.g.\n                // not make them part of the current selection as soon as they're touched.\n                keep && stored.includes(node)\n            )) {\n                removed.push(node);\n            }\n        }\n\n        _selection.selected = newlyTouched;\n        _selection.changed = {added, removed};\n        this._latestElement = newlyTouched[newlyTouched.length - 1];\n    }\n\n    _emitEvent(name: keyof SelectionEvents, evt: MouseEvent | TouchEvent | null): unknown {\n        return this.emit(name, {\n            event: evt,\n            store: this._selection,\n            selection: this\n        });\n    }\n\n    _keepSelection(): void {\n        const {_options, _selection} = this;\n        const {selected, changed, touched, stored} = _selection;\n        const addedElements = selected.filter(el => !stored.includes(el));\n\n        switch (_options.behaviour.overlap) {\n            case 'drop': {\n                _selection.stored = [\n                    ...addedElements,\n                    ...stored.filter(el => !touched.includes(el))  // Elements not touched\n                ];\n                break;\n            }\n            case 'invert': {\n                _selection.stored = [\n                    ...addedElements,\n                    ...stored.filter(el => !changed.removed.includes(el))  // Elements not removed from selection\n                ];\n                break;\n            }\n            case 'keep': {\n                _selection.stored = [\n                    ...stored,\n                    ...selected.filter(el => !stored.includes(el)) // Newly added\n                ];\n                break;\n            }\n        }\n    }\n\n    /**\n     * Manually triggers the start of a selection\n     * @param evt A MouseEvent / TouchEvent -like object\n     * @param silent If beforestart should be fired,\n     */\n    trigger(evt: MouseEvent | TouchEvent, silent = true): void {\n        this._onTapStart(evt, silent);\n    }\n\n    /**\n     * Can be used if during a selection elements have been added.\n     * Will update everything which can be selected.\n     */\n    resolveSelectables(): void {\n\n        // Resolve selectors\n        this._selectables = selectAll(this._options.selectables, this._options.document);\n    }\n\n    /**\n     * Clear the elements which where saved by 'keepSelection()'.\n     * @param includeStored If the store should also get cleared\n     */\n    clearSelection(includeStored = true): void {\n        this._selection = {\n            stored: includeStored ? [] : this._selection.stored,\n            selected: [],\n            touched: [],\n            changed: {\n                added: [],\n                removed: []\n            }\n        };\n    }\n\n    /**\n     * @returns {Array} Selected elements\n     */\n    getSelection(): Element[] {\n        return this._selection.stored;\n    }\n\n    /**\n     * @returns {HTMLElement} The selection area element\n     */\n    getSelectionArea(): HTMLElement {\n        return this._area;\n    }\n\n    /**\n     * Cancel the current selection process.\n     * @param keepEvent {boolean} true to fire a stop event after cancel.\n     */\n    cancel(keepEvent = false): void {\n        this._onTapStop(null, !keepEvent);\n    }\n\n    /**\n     * Unbinds all events and removes the area-element.\n     */\n    destroy(): void {\n        this.cancel();\n        this.disable();\n        this._clippingElement.remove();\n        super.unbindAllListeners();\n    }\n\n    /* eslint-disable no-invalid-this */\n    disable = this._bindStartEvents.bind(this, false);\n    enable = this._bindStartEvents;\n\n    /**\n     * Adds elements to the selection\n     * @param query - CSS Query, can be an array of queries\n     * @param quiet - If this should not trigger the move event\n     */\n    select(query: SelectAllSelectors, quiet = false): Element[] {\n        const {changed, selected, stored} = this._selection;\n        const elements = selectAll(query, this._options.document).filter(el =>\n            !selected.includes(el) &&\n            !stored.includes(el)\n        );\n\n        stored.push(...elements);\n        selected.push(...elements);\n        changed.added.push(...elements);\n        changed.removed = [];\n\n        // Fire event\n        if (!quiet) {\n            this._emitEvent('move', null);\n            this._emitEvent('stop', null);\n        }\n\n        return elements;\n    }\n\n    /**\n     * Removes a particular element from the selection.\n     * @param query - CSS Query, can be an array of queries\n     * @param quiet - If this should not trigger the move event\n     * @returns boolean - true if the element was successfully removed\n     */\n    deselect(query: SelectAllSelectors, quiet = false): boolean {\n        const {selected, stored, changed} = this._selection;\n\n        const elements = selectAll(query, this._options.document).filter(el =>\n            selected.includes(el) ||\n            stored.includes(el)\n        );\n\n        if (elements.length) {\n            this._selection.stored = stored.filter(el => !elements.includes(el));\n            this._selection.selected = selected.filter(el => !elements.includes(el));\n            this._selection.changed.added = [];\n            this._selection.changed.removed.push(\n                ...elements.filter(el => !changed.removed.includes(el))\n            );\n\n            // Fire event\n            if (!quiet) {\n                this._emitEvent('move', null);\n                this._emitEvent('stop', null);\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n}\n","\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype AnyFunction = (...args: any[]) => any;\ntype EventMap = Record<string, AnyFunction>;\n\nexport class EventTarget<Events extends EventMap> {\n    private readonly _listeners = new Map<keyof Events, Set<AnyFunction>>();\n\n    public addEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\n        const set = this._listeners.get(event) || new Set();\n        this._listeners.set(event, set);\n        set.add(cb as AnyFunction);\n        return this;\n    }\n\n    public removeEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\n        this._listeners.get(event)?.delete(cb as AnyFunction);\n        return this;\n    }\n\n    public dispatchEvent<K extends keyof Events>(event: K, ...data: Parameters<Events[K]>): unknown {\n        let ok = true;\n        for (const cb of (this._listeners.get(event) || [])) {\n            ok = (cb(...data) !== false) && ok;\n        }\n\n        return ok;\n    }\n\n    public unbindAllListeners(): void {\n        this._listeners.clear();\n    }\n\n    // Let's also support on, off and emit like node\n    /* eslint-disable no-invalid-this */\n    public on = this.addEventListener;\n    public off = this.removeEventListener;\n    public emit = this.dispatchEvent;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\ntype AnyFunction = (...args: any[]) => void;\n\nexport interface Frames<F extends AnyFunction = AnyFunction> {\n    next(...args: Parameters<F>): void;\n\n    cancel(): void;\n}\n\nexport const frames = <F extends AnyFunction>(fn: F): Frames<F> => {\n    let previousArgs: Parameters<F>;\n    let frameId = -1;\n    let lock = false;\n\n    return {\n        next(...args: Parameters<F>): void {\n            previousArgs = args;\n\n            if (!lock) {\n                lock = true;\n                frameId = requestAnimationFrame(() => {\n                    fn(...previousArgs);\n                    lock = false;\n                });\n            }\n        },\n        cancel() {\n            cancelAnimationFrame(frameId);\n            lock = false;\n        }\n    };\n};\n"],"names":["unitify","val","unit","css","style","attr","key","value","Object","entries","undefined","eventListener","method","items","events","fn","options","HTMLCollection","NodeList","Array","from","isArray","el","ev","capture","on","off","simplifyEvent","evt","tap","touches","x","clientX","y","clientY","target","eventPath","path","composedPath","parentElement","push","document","window","intersects","a","b","mode","bxc","left","width","byc","top","height","right","bottom","Error","selectAll","selector","doc","list","nodes","i","l","length","item","concat","querySelectorAll","Element","deepAssign","source","sourceValue","abs","max","min","ceil","Math","SelectionArea","constructor","this","_listeners","Map","addEventListener","removeEventListener","emit","dispatchEvent","event","cb","set","get","Set","add","delete","data","ok","unbindAllListeners","clear","opt","super","_selection","stored","selected","touched","changed","added","removed","_selectables","_areaRect","DOMRect","_areaLocation","y1","x2","y2","x1","_singleClick","_scrollAvailable","_scrollingActive","_scrollSpeed","_scrollDelta","disable","_bindStartEvents","bind","enable","_options","selectionAreaClass","selectionContainerClass","selectables","behaviour","overlap","intersect","startThreshold","scrolling","speedDivider","manualSpeed","startScrollMargins","features","range","touch","singleTap","allow","startAreas","boundaries","container","getOwnPropertyNames","getPrototypeOf","_area","createElement","_clippingElement","appendChild","classList","willChange","position","overflow","transform","pointerEvents","zIndex","_frame","previousArgs","frameId","lock","next","args","requestAnimationFrame","cancel","cancelAnimationFrame","frames","_recalculateSelectionAreaRect","_updateElementSelection","_emitEvent","_redrawSelectionArea","activate","_onTapStart","passive","silent","S","targetBoundingClientRect","getBoundingClientRect","resolvedBoundaries","_targetElement","find","evtPath","includes","scrollElement","scrollingElement","body","scrollLeft","scrollTop","clearSelection","_delayedTapMove","_onTapStop","_onScroll","_onSingleTap","e","resolveSelectables","v","shiftKey","reference","_latestElement","preceding","following","compareDocumentPosition","rangeItems","filter","select","ctrlKey","every","deselect","thresholdType","_onTapMove","_targetRect","scrollHeight","clientHeight","scrollWidth","clientWidth","_manualScroll","s","contains","_setupSelectionArea","_handleMoveEvent","T","$","A","tr","marginTop","marginLeft","L","scroll","distance","matchMedia","matches","preventDefault","g","deltaY","deltaX","h","x3","y3","x4","y4","u","_keepSelection","remove","o","invert","newlyTouched","node","keep","name","store","selection","addedElements","trigger","includeStored","getSelection","getSelectionArea","keepEvent","destroy","query","quiet","elements","version"],"mappings":"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"}