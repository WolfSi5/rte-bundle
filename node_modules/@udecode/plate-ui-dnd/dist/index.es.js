import { createPluginFactory, findNode, focusEditor, moveNodes, isExpanded, collapseSelection, useEditorRef, createNodesWithHOC, findNodePath, getNodeEntries, isBlock, getRange, select, getStartPoint, unhangRange, removeNodes } from '@udecode/plate-core';
import { createStyles } from '@udecode/plate-styled-components';
import _styled, { css } from 'styled-components';
import React, { useState, useRef, forwardRef, useMemo } from 'react';
import useMergedRef from '@react-hook/merged-ref';
import { getEmptyImage } from 'react-dnd-html5-backend';
import { useDrag, useDrop } from 'react-dnd';
import { Path } from 'slate';
import { useReadOnly } from 'slate-react';

const KEY_DND = 'dnd';
const createDndPlugin = createPluginFactory({
  key: KEY_DND,
  handlers: {
    onDrop: editor => () => editor.isDragging
  }
});

const getDraggableStyles = props => createStyles({
  prefixClassNames: 'Draggable',
  ...props
}, {
  root: [{
    "position": "relative"
  }, props.isDragging && {
    "opacity": "0.5"
  }, props.selected && {
    "backgroundColor": "rgb(181, 215, 255)"
  }, css([":hover .slate-Draggable-gutterLeft{", "}"], {
    "opacity": "1"
  })],
  block: {
    "overflow": "auto"
  },
  gutterLeft: [{
    "position": "absolute",
    "top": "0px",
    "display": "flex",
    "height": "100%",
    "opacity": "0",
    "pointerEvents": "none",
    "cursor": "text"
  }, css(["transform:translateX(-100%);"])],
  blockToolbarWrapper: {
    "display": "flex",
    "height": "1.5em"
  },
  blockToolbar: {
    "display": "flex",
    "alignItems": "center",
    "marginRight": "0.25rem",
    "pointerEvents": "auto"
  },
  dragHandle: [{
    "padding": "0px",
    "backgroundColor": "rgba(0, 0, 0, 0)",
    "backgroundRepeat": "no-repeat",
    "cursor": "pointer",
    "overflow": "hidden",
    "outline": "2px solid transparent",
    "outlineOffset": "2px",
    "borderStyle": "none"
  }, {
    "minWidth": "18px",
    "height": "18px"
  }],
  dropLine: [{
    "position": "absolute",
    "left": "0px",
    "right": "0px",
    "height": "0.125rem",
    "opacity": "1"
  }, {
    "background": "#B4D5FF"
  }, props.direction === 'top' && {
    "top": "-1px"
  }, props.direction === 'bottom' && {
    "bottom": "-1px"
  }]
});

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

/**
 * `useDrag` hook to drag a node from the editor. `item` with `id` is required.
 *
 * On drag start:
 * - set `editor.isDragging` to true
 * - add `dragging` class to `body`
 *
 * On drag end:
 * - set `editor.isDragging` to false
 * - remove `dragging` class to `body`
 *
 * Collect:
 * - isDragging: true if mouse is dragging the block
 */
const useDragNode = (editor, {
  id,
  item,
  ...options
}) => {
  return useDrag(() => ({
    item(monitor) {
      editor.isDragging = true;
      document.body.classList.add('dragging');

      const _item = typeof item === 'function' ? item(monitor) : item;

      return {
        id,
        ..._item
      };
    },

    collect: monitor => ({
      isDragging: monitor.isDragging()
    }),
    end: () => {
      editor.isDragging = false;
      document.body.classList.remove('dragging');
    },
    ...options
  }), []);
};

/**
 * If dragging a node A over another node B:
 * get the direction of node A relative to node B.
 */
const getHoverDirection = ({
  dragItem,
  id,
  monitor,
  nodeRef
}) => {
  var _nodeRef$current;

  if (!nodeRef.current) return;
  const dragId = dragItem.id; // Don't replace items with themselves

  if (dragId === id) return; // Determine rectangle on screen

  const hoverBoundingRect = (_nodeRef$current = nodeRef.current) === null || _nodeRef$current === void 0 ? void 0 : _nodeRef$current.getBoundingClientRect(); // Get vertical middle

  const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2; // Determine mouse position

  const clientOffset = monitor.getClientOffset();
  if (!clientOffset) return; // Get pixels to the top

  const hoverClientY = clientOffset.y - hoverBoundingRect.top; // Only perform the move when the mouse has crossed half of the items height
  // When dragging downwards, only move when the cursor is below 50%
  // When dragging upwards, only move when the cursor is above 50%
  // Dragging downwards
  // if (dragId < hoverId && hoverClientY < hoverMiddleY) {

  if (hoverClientY < hoverMiddleY) {
    return 'top';
  } // Dragging upwards
  // if (dragId > hoverId && hoverClientY > hoverMiddleY) {


  if (hoverClientY >= hoverMiddleY) {
    return 'bottom';
  }
};

/**
 * Get new direction if updated
 */
const getNewDirection = (previousDir, dir) => {
  if (!dir && previousDir) {
    return '';
  }

  if (dir === 'top' && previousDir !== 'top') {
    return 'top';
  }

  if (dir === 'bottom' && previousDir !== 'bottom') {
    return 'bottom';
  }
};

/**
 * Callback called on drag an drop a node with id.
 */

const onDropNode = (editor, {
  dragItem,
  monitor,
  nodeRef,
  id
}) => {
  const direction = getHoverDirection({
    dragItem,
    monitor,
    nodeRef,
    id
  });
  if (!direction) return;
  const dragEntry = findNode(editor, {
    at: [],
    match: {
      id: dragItem.id
    }
  });
  if (!dragEntry) return;
  const [, dragPath] = dragEntry;
  focusEditor(editor);
  let dropPath;

  if (direction === 'bottom') {
    var _findNode;

    dropPath = (_findNode = findNode(editor, {
      at: [],
      match: {
        id
      }
    })) === null || _findNode === void 0 ? void 0 : _findNode[1];
    if (!dropPath) return;
    if (Path.equals(dragPath, Path.next(dropPath))) return;
  }

  if (direction === 'top') {
    var _findNode2;

    const nodePath = (_findNode2 = findNode(editor, {
      at: [],
      match: {
        id
      }
    })) === null || _findNode2 === void 0 ? void 0 : _findNode2[1];
    if (!nodePath) return;
    dropPath = [...nodePath.slice(0, -1), nodePath[nodePath.length - 1] - 1];
    if (Path.equals(dragPath, dropPath)) return;
  }

  if (direction) {
    const _dropPath = dropPath;
    const before = Path.isBefore(dragPath, _dropPath) && Path.isSibling(dragPath, _dropPath);
    const to = before ? _dropPath : Path.next(_dropPath);
    moveNodes(editor, {
      at: dragPath,
      to
    });
  }
};

/**
 * Callback called when dragging a node and hovering nodes.
 */

const onHoverNode = (editor, {
  dragItem,
  monitor,
  nodeRef,
  onChangeDropLine,
  dropLine,
  id
}) => {
  const direction = getHoverDirection({
    dragItem,
    monitor,
    nodeRef,
    id
  });
  const dropLineDir = getNewDirection(dropLine, direction);
  if (dropLineDir) onChangeDropLine(dropLineDir);

  if (direction && isExpanded(editor.selection)) {
    focusEditor(editor);
    collapseSelection(editor);
  }
};

/**
 * `useDrop` hook to drop a node on the editor.
 *
 * On drop:
 * - get hover direction (top, bottom or undefined), return early if undefined
 * - dragPath: find node with id = dragItem.id, return early if not found
 * - focus editor
 * - dropPath: find node with id = id, its path should be next (bottom) or previous (top)
 * - move node from dragPath to dropPath
 *
 * On hover:
 * - get drop line direction
 * - if differs from dropLine, setDropLine is called
 *
 * Collect:
 * - isOver: true if mouse is over the block
 */
const useDropNode = (editor, {
  nodeRef,
  id,
  dropLine,
  onChangeDropLine,
  ...options
}) => {
  return useDrop({
    drop: (dragItem, monitor) => {
      onDropNode(editor, {
        nodeRef,
        id,
        dragItem,
        monitor
      });
    },
    collect: monitor => ({
      isOver: monitor.isOver()
    }),

    hover(item, monitor) {
      onHoverNode(editor, {
        nodeRef,
        id,
        dropLine,
        onChangeDropLine,
        dragItem: item,
        monitor
      });
    },

    ...options
  });
};

/**
 * {@link useDragNode} and {@link useDropNode} hooks to drag and drop a node from the editor.
 * A default preview is used to show the node being dragged, which can be customized or removed.
 * Returns the drag ref and drop line direction.
 */
const useDndNode = ({
  id,
  type,
  nodeRef,
  preview: previewOptions = {},
  drag: dragOptions,
  drop: dropOptions
}) => {
  const editor = useEditorRef();
  const [dropLine, setDropLine] = useState('');
  const [{
    isDragging
  }, dragRef, preview] = useDragNode(editor, {
    id,
    type,
    ...dragOptions
  });
  const [{
    isOver
  }, drop] = useDropNode(editor, {
    accept: type,
    id,
    nodeRef,
    dropLine,
    onChangeDropLine: setDropLine,
    ...dropOptions
  });

  if (previewOptions.disable) {
    drop(nodeRef);
    preview(getEmptyImage(), {
      captureDraggingState: true
    });
  } else if (previewOptions.ref) {
    drop(nodeRef);
    preview(previewOptions.ref);
  } else {
    preview(drop(nodeRef));
  }

  if (!isOver && dropLine) {
    setDropLine('');
  }

  return {
    isDragging,
    isOver,
    dropLine,
    dragRef
  };
};

const DRAG_ITEM_BLOCK = 'block';
/**
 * {@link useDragNode}
 */

const useDragBlock = (editor, id) => useDragNode(editor, {
  id,
  type: DRAG_ITEM_BLOCK
});

/**
 * {@link useDndNode}
 */

const useDndBlock = options => useDndNode({
  type: DRAG_ITEM_BLOCK,
  ...options
});

const DefaultDragHandle = ({
  styles,
  ...props
}) => /*#__PURE__*/React.createElement(_StyledButton, _extends({
  type: "button"
}, props, {
  $_css: styles
}));

const Draggable = props => {
  var _styles$gutterLeft, _styles$blockAndGutte, _styles$blockAndGutte2, _styles$gutterLeft$cs, _styles$gutterLeft2, _styles$blockToolbarW, _styles$blockToolbarW2, _styles$blockToolbar, _styles$blockToolbar2, _styles$dragHandle, _styles$dragHandle2, _styles$blockAndGutte3, _styles$blockAndGutte4, _styles$block$css, _styles$block, _styles$dropLine, _styles$dropLine2;

  const {
    children,
    element,
    componentRef,
    onRenderDragHandle
  } = props;
  const DragHandle = onRenderDragHandle !== null && onRenderDragHandle !== void 0 ? onRenderDragHandle : DefaultDragHandle;
  const blockRef = useRef(null);
  const rootRef = useRef(null);
  const dragWrapperRef = useRef(null);
  const multiRootRef = useMergedRef(componentRef, rootRef);
  const {
    dropLine,
    dragRef,
    isDragging
  } = useDndBlock({
    id: element.id,
    nodeRef: rootRef
  });
  const multiDragRef = useMergedRef(dragRef, dragWrapperRef);
  const styles = getDraggableStyles({ ...props,
    direction: dropLine,
    isDragging
  });
  return /*#__PURE__*/React.createElement(_StyledDiv, {
    className: styles.root.className,
    ref: multiRootRef,
    $_css2: styles.root.css
  }, /*#__PURE__*/React.createElement(_StyledDiv2, {
    className: (_styles$gutterLeft = styles.gutterLeft) === null || _styles$gutterLeft === void 0 ? void 0 : _styles$gutterLeft.className,
    contentEditable: false,
    $_css3: [...((_styles$blockAndGutte = (_styles$blockAndGutte2 = styles.blockAndGutter) === null || _styles$blockAndGutte2 === void 0 ? void 0 : _styles$blockAndGutte2.css) !== null && _styles$blockAndGutte !== void 0 ? _styles$blockAndGutte : []), ...((_styles$gutterLeft$cs = (_styles$gutterLeft2 = styles.gutterLeft) === null || _styles$gutterLeft2 === void 0 ? void 0 : _styles$gutterLeft2.css) !== null && _styles$gutterLeft$cs !== void 0 ? _styles$gutterLeft$cs : [])]
  }, /*#__PURE__*/React.createElement(_StyledDiv3, {
    className: (_styles$blockToolbarW = styles.blockToolbarWrapper) === null || _styles$blockToolbarW === void 0 ? void 0 : _styles$blockToolbarW.className,
    $_css4: (_styles$blockToolbarW2 = styles.blockToolbarWrapper) === null || _styles$blockToolbarW2 === void 0 ? void 0 : _styles$blockToolbarW2.css
  }, /*#__PURE__*/React.createElement(_StyledDiv4, {
    className: (_styles$blockToolbar = styles.blockToolbar) === null || _styles$blockToolbar === void 0 ? void 0 : _styles$blockToolbar.className,
    ref: multiDragRef,
    $_css5: (_styles$blockToolbar2 = styles.blockToolbar) === null || _styles$blockToolbar2 === void 0 ? void 0 : _styles$blockToolbar2.css
  }, /*#__PURE__*/React.createElement(DragHandle, {
    element: element,
    styles: (_styles$dragHandle = styles.dragHandle) === null || _styles$dragHandle === void 0 ? void 0 : _styles$dragHandle.css,
    className: (_styles$dragHandle2 = styles.dragHandle) === null || _styles$dragHandle2 === void 0 ? void 0 : _styles$dragHandle2.className,
    onMouseDown: e => e.stopPropagation()
  })))), /*#__PURE__*/React.createElement(_StyledDiv5, {
    ref: blockRef,
    $_css6: [...((_styles$blockAndGutte3 = (_styles$blockAndGutte4 = styles.blockAndGutter) === null || _styles$blockAndGutte4 === void 0 ? void 0 : _styles$blockAndGutte4.css) !== null && _styles$blockAndGutte3 !== void 0 ? _styles$blockAndGutte3 : []), ...((_styles$block$css = (_styles$block = styles.block) === null || _styles$block === void 0 ? void 0 : _styles$block.css) !== null && _styles$block$css !== void 0 ? _styles$block$css : [])]
  }, children, !!dropLine && /*#__PURE__*/React.createElement(_StyledDiv6, {
    className: (_styles$dropLine = styles.dropLine) === null || _styles$dropLine === void 0 ? void 0 : _styles$dropLine.className,
    contentEditable: false,
    $_css7: (_styles$dropLine2 = styles.dropLine) === null || _styles$dropLine2 === void 0 ? void 0 : _styles$dropLine2.css
  })));
};

var _StyledButton = _styled("button").withConfig({
  displayName: "Draggable___StyledButton",
  componentId: "sc-fk3pif-0"
})(["", ""], p => p.$_css);

var _StyledDiv = _styled("div").withConfig({
  displayName: "Draggable___StyledDiv",
  componentId: "sc-fk3pif-1"
})(["", ""], p => p.$_css2);

var _StyledDiv2 = _styled("div").withConfig({
  displayName: "Draggable___StyledDiv2",
  componentId: "sc-fk3pif-2"
})(["", ""], p => p.$_css3);

var _StyledDiv3 = _styled("div").withConfig({
  displayName: "Draggable___StyledDiv3",
  componentId: "sc-fk3pif-3"
})(["", ""], p => p.$_css4);

var _StyledDiv4 = _styled("div").withConfig({
  displayName: "Draggable___StyledDiv4",
  componentId: "sc-fk3pif-4"
})(["", ""], p => p.$_css5);

var _StyledDiv5 = _styled("div").withConfig({
  displayName: "Draggable___StyledDiv5",
  componentId: "sc-fk3pif-5"
})(["", ""], p => p.$_css6);

var _StyledDiv6 = _styled("div").withConfig({
  displayName: "Draggable___StyledDiv6",
  componentId: "sc-fk3pif-6"
})(["", ""], p => p.$_css7);

const GrabberTooltipContent = () => /*#__PURE__*/React.createElement("div", {
  style: {
    fontSize: 12
  }
}, /*#__PURE__*/React.createElement("div", null, "Drag ", /*#__PURE__*/React.createElement("span", {
  style: {
    color: 'rgba(255, 255, 255, 0.45)'
  }
}, "to move")));

const grabberTooltipProps = {
  content: /*#__PURE__*/React.createElement(GrabberTooltipContent, null),
  placement: 'bottom',
  arrow: false,
  offset: [0, 0],
  delay: [300, 0],
  duration: [0, 0],
  hideOnClick: true,
  theme: 'small'
};

const withDraggable = (Component, {
  styles,
  level = 0,
  filter,
  allowReadOnly = false,
  onRenderDragHandle
} = {}) => {
  return /*#__PURE__*/forwardRef((props, ref) => {
    const {
      attributes,
      element,
      editor
    } = props;
    const readOnly = useReadOnly();
    const path = useMemo(() => findNodePath(editor, element), [editor, element]);
    const filteredOut = useMemo(() => path && (Number.isInteger(level) && level !== path.length - 1 || filter && filter(editor, path)), [path, editor]);

    if (filteredOut || !allowReadOnly && readOnly) {
      return /*#__PURE__*/React.createElement(Component, props);
    }

    return /*#__PURE__*/React.createElement(Draggable, {
      editor: editor,
      attributes: attributes,
      element: element,
      componentRef: ref,
      styles: styles,
      onRenderDragHandle: onRenderDragHandle
    }, /*#__PURE__*/React.createElement(Component, props));
  });
};
const withDraggables = createNodesWithHOC(withDraggable);

/**
 * {@link useDropNode}
 */

const useDropBlock = (editor, options) => useDropNode(editor, {
  accept: DRAG_ITEM_BLOCK,
  ...options
});

/**
 * Get blocks with an id
 */

const getBlocksWithId = (editor, options) => {
  const _nodes = getNodeEntries(editor, {
    match: n => isBlock(editor, n) && !!n.id,
    ...options
  });

  return Array.from(_nodes);
};

/**
 * Get node entries range.
 */

const getNodesRange = (editor, nodeEntries) => {
  if (!nodeEntries.length) return;
  const firstBlockPath = nodeEntries[0][1];
  const lastBlockPath = nodeEntries[nodeEntries.length - 1][1];
  return getRange(editor, firstBlockPath, lastBlockPath);
};

/**
 * Select the start of a block by id and focus the editor.
 */

const focusBlockStartById = (editor, id) => {
  var _findNode;

  const path = (_findNode = findNode(editor, {
    at: [],
    match: {
      id
    }
  })) === null || _findNode === void 0 ? void 0 : _findNode[1];
  if (!path) return;
  select(editor, getStartPoint(editor, path));
  focusEditor(editor);
};

/**
 * Remove blocks with an id and focus the editor.
 */

const removeBlocksAndFocus = (editor, options) => {
  unhangRange(editor, options === null || options === void 0 ? void 0 : options.at, options);
  const nodeEntries = getBlocksWithId(editor, options);
  removeNodes(editor, {
    at: getNodesRange(editor, nodeEntries)
  });
  focusEditor(editor);
};

/**
 * Select the block above the selection by id and focus the editor.
 */

const selectBlockById = (editor, id) => {
  var _findNode;

  const path = (_findNode = findNode(editor, {
    at: [],
    match: {
      id
    }
  })) === null || _findNode === void 0 ? void 0 : _findNode[1];
  if (!path) return;
  select(editor, getRange(editor, path));
  focusEditor(editor);
};

/**
 * Select blocks by selection or by id.
 * If the block with id is not selected, select the block with id.
 * Else, select the blocks above the selection.
 */

const selectBlocksBySelectionOrId = (editor, id) => {
  if (!editor.selection) return;
  const blockEntries = getBlocksWithId(editor, {
    at: editor.selection
  });
  const isBlockSelected = blockEntries.some(blockEntry => blockEntry[0].id === id);

  if (isBlockSelected) {
    select(editor, getNodesRange(editor, blockEntries));
    focusEditor(editor);
  } else {
    selectBlockById(editor, id);
  }
};

export { DRAG_ITEM_BLOCK, Draggable, KEY_DND, createDndPlugin, focusBlockStartById, getBlocksWithId, getDraggableStyles, getHoverDirection, getNewDirection, getNodesRange, grabberTooltipProps, onDropNode, onHoverNode, removeBlocksAndFocus, selectBlockById, selectBlocksBySelectionOrId, useDndBlock, useDndNode, useDragBlock, useDragNode, useDropBlock, useDropNode, withDraggable, withDraggables };
//# sourceMappingURL=index.es.js.map
