import { createStore, useEditorRef, findNodePath, isInline, getPluginOptions, queryNode, useHotkeys, findNode, focusEditor, getEndPoint, withoutNormalizing, removeNodes, deselectEditor, createComponentAs, createElementAs, createPluginFactory } from '@udecode/plate-core';
import React, { useMemo, useEffect, createRef } from 'react';
import VanillaSelectionArea from '@viselect/vanilla';

const extractSelectableIds = els => {
  return els.map(v => v.getAttribute('data-key'));
};

const blockSelectionStore = createStore('selection')({
  selectedIds: new Set()
}).extendActions((set, get) => ({
  setSelectedIds: ({
    added,
    removed
  }) => {
    const prev = get.selectedIds();
    const next = new Set(prev);
    extractSelectableIds(added).forEach(id => next.add(id));
    extractSelectableIds(removed).forEach(id => next.delete(id));
    set.selectedIds(next);
  },
  reset: () => {
    set.selectedIds(new Set());
  }
})).extendSelectors((set, get) => ({
  isSelecting: () => get.selectedIds().size > 0,
  isSelected: id => id && get.selectedIds().has(id)
}));
const useBlockSelectionSelectors = () => blockSelectionStore.use;
const blockSelectionSelectors = blockSelectionStore.get;
const blockSelectionActions = blockSelectionStore.set;

const useBlockSelectableState = ({
  element,
  state
}) => {
  const editor = useEditorRef();
  const path = useMemo(() => findNodePath(editor, element), [editor, element]);

  if (!path || isInline(editor, element)) {
    return {
      active: false,
      ...state
    };
  }

  const {
    query
  } = getPluginOptions(editor, KEY_BLOCK_SELECTION);

  if (query && !queryNode([element, path], query)) {
    return {
      active: false,
      ...state
    };
  }

  return {
    active: true,
    ...state
  };
};
const useBlockSelectable = ({
  element,
  selectedColor,
  ...props
}) => {
  const id = element.id;
  const isSelected = useBlockSelectionSelectors().isSelected(id);
  return {
    className: isSelected ? 'slate-selected slate-selectable' : 'slate-selectable',
    style: isSelected ? {
      backgroundColor: selectedColor
    } : undefined,
    'data-key': id,
    key: id,
    ...props
  };
};
const BlockSelectable = props => {
  const htmlProps = useBlockSelectable(props);
  const {
    active
  } = useBlockSelectableState(props);
  if (!active) return /*#__PURE__*/React.createElement(React.Fragment, null, htmlProps.children);
  return /*#__PURE__*/React.createElement("div", htmlProps);
};

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

const SelectionArea = ({
  onBeforeStart,
  onStart,
  onMove,
  onStop,
  children,
  selectionAreaClass,
  selectionContainerClass,
  container,
  document,
  selectables,
  startAreas,
  behaviour,
  features,
  getBoundaries = boundaries => boundaries,
  ...props
}) => {
  const ref = /*#__PURE__*/createRef();
  /* eslint-disable react-hooks/exhaustive-deps */

  useEffect(() => {
    const opt = {
      selectionAreaClass,
      selectionContainerClass,
      container,
      document,
      selectables,
      startAreas,
      behaviour,
      features
    };
    const areaBoundaries = ref.current;
    const selection = new VanillaSelectionArea({
      boundaries: getBoundaries(areaBoundaries),
      ...opt
    });
    onBeforeStart && selection.on('beforestart', onBeforeStart);
    onStart && selection.on('start', onStart);
    onMove && selection.on('move', onMove);
    onStop && selection.on('stop', onStop);
    return () => selection.destroy();
  }, []);
  return /*#__PURE__*/React.createElement("div", _extends({
    ref: ref
  }, props), children);
};

const useBlockSelectionArea = ({
  enterHotkeyOptions,
  deleteHotkeyOptions,
  ...props
}) => {
  const editor = useEditorRef();
  useHotkeys('enter', () => {
    if (blockSelectionSelectors.isSelecting()) {
      // get the first block in the selection
      const entry = findNode(editor, {
        match: n => blockSelectionSelectors.selectedIds().has(n.id)
      });

      if (entry) {
        const [, path] = entry;
        setTimeout(() => {
          // focus the end of that block
          focusEditor(editor, getEndPoint(editor, path));
          blockSelectionActions.reset();
        }, 0);
      }
    }
  }, enterHotkeyOptions, []);
  useHotkeys('backspace, delete', () => {
    if (blockSelectionSelectors.isSelecting()) {
      withoutNormalizing(editor, () => {
        blockSelectionSelectors.selectedIds().forEach(id => {
          const entry = findNode(editor, {
            match: {
              id
            }
          });

          if (entry) {
            const [, path] = entry;
            removeNodes(editor, {
              at: path
            });
          }
        });
      });
      setTimeout(() => {
        blockSelectionActions.reset();
      }, 0);
    }
  }, deleteHotkeyOptions, []);

  const onStart = ({
    event,
    selection
  }) => {
    deselectEditor(editor);

    if (!(event !== null && event !== void 0 && event.shiftKey)) {
      selection.clearSelection();
      blockSelectionActions.reset();
    }
  };

  const onMove = ({
    store: {
      changed
    }
  }) => {
    if (!changed.added.length && !changed.removed.length) return;
    blockSelectionActions.setSelectedIds(changed);
  };

  return {
    className: 'slate-SelectionArea',
    style: {
      position: 'relative'
    },
    onStart,
    onMove,
    // Class for the selection-area itself (the element).
    selectionAreaClass: 'slate-selection-area',
    // Class for the selection-area container.
    // selectionContainerClass="selection-area-container"
    // Query selector or dom-node to set up container for the selection-area element.
    // container="body"
    // document object - if you want to use it within an embed document (or iframe).
    // document={window.document}
    // Query selectors for elements which can be selected.
    selectables: '.slate-selectable',
    // Query selectors for elements from where a selection can be started from.
    startAreas: '.slate-start-area',
    // Query selectors for elements which will be used as boundaries for the selection.
    // boundaries={['html']}
    // Behaviour related options.
    // behaviour={{
    //   // Specifies what should be done if already selected elements get selected again.
    //   //   invert: Invert selection for elements which were already selected
    //   //   keep: Keep selected elements (use clearSelection() to remove those)
    //   //   drop: Remove stored elements after they have been touched
    //   overlap: 'invert',
    //
    //   // On which point an element should be selected.
    //   // Available modes are cover (cover the entire element), center (touch the center) or
    //   // the default mode is touch (just touching it).
    //   intersect: 'touch',
    //
    //   // px, how many pixels the point should move before starting the selection (combined distance).
    //   // Or specifiy the threshold for each axis by passing an object like {x: <number>, y: <number>}.
    //   startThreshold: 10,
    //
    //   // Scroll configuration.
    //   scrolling: {
    //     // On scrollable areas the number on px per frame is devided by this amount.
    //     // Default is 10 to provide a enjoyable scroll experience.
    //     speedDivider: 10,
    //
    //     // Browsers handle mouse-wheel events differently, this number will be used as
    //     // numerator to calculate the mount of px while scrolling manually: manualScrollSpeed / scrollSpeedDivider.
    //     manualSpeed: 750,
    //
    //     // This property defines the virtual inset margins from the borders of the container
    //     // component that, when crossed by the mouse/touch, trigger the scrolling. Useful for
    //     // fullscreen containers.
    //     startScrollMargins: { x: 0, y: 0 },
    //   },
    // }}
    // // Features.
    // features={{
    //   // Enable / disable touch support.
    //   touch: true,
    //
    //   // Range selection.
    //   range: true,
    //
    //   // Configuration in case a selectable gets just clicked.
    //   singleTap: {
    //     // Enable single-click selection (Also disables range-selection via shift + ctrl).
    //     allow: true,
    //
    //     // 'native' (element was mouse-event target) or 'touch' (element visually touched).
    //     intersect: 'native',
    //   },
    // }}
    ...props
  };
};
const BlockSelectionArea = props => {
  const componentProps = useBlockSelectionArea(props);
  return /*#__PURE__*/React.createElement(SelectionArea, componentProps);
};

const useBlockStartArea = ({
  placement = 'left',
  size = 'auto',
  ...props
}) => {
  return { ...props,
    className: `slate-start-area slate-start-area-${placement}`,
    style: {
      position: 'absolute',
      top: ['top', 'left', 'right'].includes(placement) ? 0 : undefined,
      left: ['top', 'left', 'bottom'].includes(placement) ? 0 : undefined,
      bottom: ['bottom'].includes(placement) ? 0 : undefined,
      right: ['right'].includes(placement) ? 0 : undefined,
      width: ['left', 'right'].includes(placement) ? size : '100%',
      height: ['top', 'bottom'].includes(placement) ? size : '100%',
      zIndex: 1,
      userSelect: 'none',
      cursor: 'text',
      ...(props === null || props === void 0 ? void 0 : props.style)
    }
  };
};
const BlockStartArea = createComponentAs(props => createElementAs('div', useBlockStartArea(props)));

const KEY_BLOCK_SELECTION = 'blockSelection';
const createBlockSelectionPlugin = createPluginFactory({
  key: KEY_BLOCK_SELECTION,
  options: {
    query: {
      maxLevel: 1
    }
  },
  inject: {
    aboveComponent: () => ({
      element,
      children
    }) => BlockSelectable({
      element,
      children,
      selectedColor: 'rgb(219 234 254)'
    })
  },
  handlers: {
    onFocus: () => () => {
      blockSelectionActions.reset();
    }
  },
  renderAboveEditable: ({
    children
  }) => /*#__PURE__*/React.createElement(BlockSelectionArea, null, /*#__PURE__*/React.createElement(BlockStartArea, {
    size: 28,
    placement: "left"
  }), /*#__PURE__*/React.createElement(BlockStartArea, {
    size: 50,
    placement: "top"
  }), /*#__PURE__*/React.createElement(BlockStartArea, {
    size: 50,
    placement: "right"
  }), /*#__PURE__*/React.createElement(BlockStartArea, {
    size: 50,
    placement: "bottom"
  }), children)
});

export { BlockSelectable, BlockSelectionArea, BlockStartArea, KEY_BLOCK_SELECTION, SelectionArea, blockSelectionActions, blockSelectionSelectors, blockSelectionStore, createBlockSelectionPlugin, extractSelectableIds, useBlockSelectable, useBlockSelectableState, useBlockSelectionArea, useBlockSelectionSelectors, useBlockStartArea };
//# sourceMappingURL=index.es.js.map
